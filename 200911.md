###### 20/09/11

------



#### Index

### **1.  Optional**

-  Optional Type
-  Unwrapping 



------



### **1.  Optional**

- #### Optional Type

  - 값을 저장할 수도 있고, 저장하지 않을(nil)수도 있다.
  - Non-optional Type 뒤에 `?`를 붙여준다.

  - `nil`은 값이 없음을 나타내는 키워드이다.
  - `nil`은 추론할 수 있는 형식이 없기 때문에, 꼭 Type annotation으로 타입을 지정해주어야 한다.
  - 표현식을 평가한 결과가 Optional로 return이 되면, Optional Expression이라고 한다.

  ```swift
  var num1: Int = 0
  var num2: Int? = nil
  ```

  

- #### Unwrapping

  - Optional로 포장되어있는 값을 추출하는 것을 Unwrapping이라고 한다. Unwrapping하면 Non-optional Type으로 결과가 return된다.
  - Optional Type에 저장된 값을 사용하려면 반드시 Unwrapping해야 한다. 

  

  - Forced Unwrapping (강제 추출)

    - Optional Expression 뒤에 `!` 문자를 사용해서 강제추출한다.

    - **nil(값이 없음)이 저장되어있을 때 강제추출하면 Crash가 발생**한다.

    - 꺼낼 값이 있을 때만 강제추출한다.

      ```swift
      var number: Int? = 1
      number! + 10
      
      // number를 강제추출
      ```

      

  - Optional Binding 

    ```swift
    if let name: Type = OptionalExpression {
    statements
    }
    
    // let name: Type = OptionalExpression
    // 이 부분을 Binding이라고 부른다. ✨
    ```

    - if문 뒤에 condition이 아니라, 상수 선언 문법이 온다. 대신, 초기값은 Optional Expression으로 대체된다.
    - 기존의 if문은 condition을 평가하고 코드가 실행되었지만, Binding은 코드가 실행되는 조건이 다르다.
      1. 먼저 Optional Expression을 평가한다.
      2. 값이 return이 된다면,  **Unrapping되어 임시상수에 저장**이 된다. (Binding에 성공, 필요에 따라 변수도 사용할 수 있다.)
      3. 반대로 nil이 return이 된다면, Binding에 실패했기 때문에 다음 문장으로 제어를 넘긴다.
    - Optional Expression이 값을 return하는 경우에만 Unrapping하기 때문에, 강제추출과 같은 에러는 발생하지 않는다.

    ```swift
    var str: String? = "str"
    
    guard let str = str else {
        fatalError()
    }
    str
    
    // guard문에서 binding한 상수는, 꼭 else블록 다음에 사용해야 한다.
    ```

    ```swift
    let a: Int? = 0
    let b: String? = "str"
    
    if let num = a, let str = b, str.count > 2 {
    	print("Hello, Swift")
    }
    
    // Binding을 한 번 이상 사용할 수 있고, condition도 추가할 수 있다.
    ```

  

  - Implicitly Unwrapped Optional (IUO)

    - 어떤 특정 조건에서  값이 자동으로 추출된다.
    - IUO는 형식추론을 사용하는 경우 자동으로 추출되지 않는다.
    - nil이 저장되어 있는 상태에서 값을 추출하면 에러가 발생한다.

    ```swift
    let num: Int! = 12
    
    let a = num
    a
    
    let b: Int = num
    ```

    

  - Nil-Coalescing Operator

    - Nil-Coalescing Operator를 사용하면 값이 저장되어있는지 확인하는 코드와 값을 추출하는 코드를 직접 작성할 필요가 없다.
    - 이상 연산자다.
    - 왼쪽의 피연산자는 항상 Optional Expression이어야 하고, 오른쪽 피연산자는 Non-Optional Expression이어야 한다.
    - 먼저 왼쪽에 있는 피연산자에 값이 저장되어 있는지 확인한다(= Optional Expression이 값을 return하는지 확인한다). 값을 리턴한다면, 이 값을 Unwrapping한 다음 연산의 결과로 return한다.
    - 만약 값이 저장되어 있지 않았다면(=Optional Expression이 값을 return하지 않았다면), 오른쪽 피연산자를 평가하고 그 결과를 리턴한다.
      주로 값이 없을 때 사용할 기본값을 전달한다.
    - 오른쪽 피연산자에는 Side Effect가 발생하는 코드가 오면 안된다.

    ```swift
    var msg = ""
    var input: String? = "Swift"
    
    if let inputName = input {
        msg = "Hello, " + inputName
    } else {
        msg = "Hello, Stranger"
    }
    
    print(msg)
    
    // 코드를 단순하게 해본다면,
    
    var str = "Hello, " + (input != nil ? input! : "Stranger")
    print(str)
    
    
    // Nil-Coalescing Operator를 사용해본다면,
    
     str = "hello, " + (input ?? "Stranger")
    
    // input이라는 변수에 Swift라는 값이 저장되어 있기 때문에, Unwrapping한 다음 hello, 라는 문자열과 연결한다.
    ```

    

