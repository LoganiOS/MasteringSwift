###### 20/09/09

------



#### Index

### **1. 연산자**

-  연산자 기초 이론
- 산술 연산자 (Arithmetic Operators)
- Overflow 연산자
- 비교 연산자
- 논리 연산자
- 삼항 연산자
- 할당 연산자
- 복합 할당 연산자
- 범위 연산자
- 연산자 메소드
- 연산자 선언



### **2. 기타메모**



------



### 1. 연산자

- #### 연산자 기초 이론

  - ` a + b` 에서 연산에 사용되는 + 문자를 연산자(영어로는 Operator)라고 하고, 계산에 사용되는 값(a와 b)을 피연산자(Operand)라고 한다. 프로그래밍 언어에선 문자열을 더할 수도 있고, 직접 만든 자료형에서도 연산을 구현할 수 있다.

  

  - Unary Operator(단항연산자): 피연산자가 한 개인 경우

    ```swift
    +a  // 🙆
    + a // 🙅
    
    // 단항연산자를 사용할 경우 연산자와 피연산자 사이에 공백이 없어야 한다!
    ```

  

  - Binary Operator(이항연산자): 피연산자가 두 개인 경우

    ```swift
    a+b // 1. 🙆...🤷
    a + b // 2. 🙆
    a+ b // 3. 🙅
    
    // 이항연산자를 사용할 경우 연산자와 피연산자 사이에 공백이 같아야 한다.
    // 사이 공백을 주지 않아도 되지만, 가끔 오류가 날 수 있으므로 2번째 예시가 권장!
    ```

  

  - Ternary Operator(삼항연산자 또는 조건연산자): 피연산자가 세 개인 경우

    ```swift
    a ? b : C
    
    // 양쪽에 공백을 한 칸씩 주어야 한다.
    ```

    

  - `Precedence(우선순위)`    연산자마다 Precedence(우선순위)를 가지고 있다. 먼저 계산하고 싶은 식에 `() Parentheses` 를 사용해서 우선순위를 줄 수 있다.

  

  - `Associativity(결합규칙)`    우선 순위가 없을 경우 좌결합성(왼쪽에서 오른쪽으로 계산)

  

  - 연산자 위치에 따라 연산자가 앞에 있다면 전치 연산자(prefix), 뒤에 있다면 후치 연산자(postfix), 안쪽에 있다면 infix라고 부른다.



- #### 산술 연산자  

  ` / 나누기의 몫` 	` * 곱하기` 	` % 나머지`

  ```swift
  let a = 10
  let b = 2
  
  a / b // 5
  a * b // 20
  a % b // 0
  ```




- #### Overflow

  자료형에 저장할 수 있는 값의 범위를 초과하는 것을 Overflow라고 한다. Swift 산술 연산자가 (산술)Overflow를 허용하지 않지만, 특정 패턴을 구현하기 위해 Overflow연산자를 사용한다.

  📋 Compile Time에 발견한 Overflow는 더 큰 자료형으로 변경해주면 문제를 해결할 수 있다.

  ```swift
  let a: Int8 = Int8.max // 127
  let b: Int8 = a + 1 // 컴파일 에러가 발생한다. 
  ```

  연산자 앞에 `&(앰퍼샌드)`를 붙여서 Overflow 연산을 허용할 수 있다.	

  ```swift
  let a: Int8 = Int8.max // 127
  let b: Int8 = a &+ 1 // -128
  
  //📋 메모리 크기가 늘어나는 연산자가 아님! 값이 순환하기 때문에 -128이 된다.
  ```

  📋 지금(2020년 9월 9일 기준)은 왕초보니까 모르는 척 하기 😢



- #### 비교 연산자

  - 비교 연산자는 이항 연산자에 사용되고, 결과는 항상 bool(true 또는 false)값이어야 한다.
  - 피연산자의 자료형이 같아야 비교 가능!
  - `== Equa to  `                두 값이 같으면 true
  - `!=  Not Equa to  `      두 값이 다르면 true
  - `>, >=, <, <=  `            크기를 비교하는 비교 연산자 




- #### 논리 연산자

  - 참과 거짓을 구분하는 연산자고, 피연산자와 결과가 모두 boolean 표현식이어야 한다. ✨

  - `!`       Logical Not Operators (논리 부정 연산자)로 참을 거짓으로, 거짓을 참으로 바꿔준다. 전치 연산자로만 사용.

  - `&&`     Logical And Operators로 모든 피연산자가 true일때만 true가 리턴이 되고 나머지 경우에는 모두 false로
             리턴이 된다.
     
  - `||`     Logical OR Operators로 하나의 피연산자가 true여도 true가 리턴이 된다.

  - `Short-circuit Evaluation`  단락평가, 결과 도출에 필요한 최소한의 논리식만 평가하는 방식 ✨
  
  - `Side Effect`     코드의 실행 결과로 인해, 값 또는 상태가 변경되는 것.
                              논리식에 Side Effect를 발생시킬 수 있는 코드가 포함되어 있는 경우,
                                 논리적인 오류가 발생할 수 있기 때문에 조심해야 한다.
     
     ```swift
     true && true // true
     true && false // false
     false && true // false
     false && false // false
     
     // 📋 Short-circuit evaluation(단락평가)
     			값이 true일 때 실행되는 코드를 Logical And Operator를 사용할 때 첫번째 피연산자가 false라면,
     			두번째 피연산자를 평가하지 않기 때문에 효율적으로 사용할 수 있다.
     
     true || true // true
     true || false // true
     false || true // true
     false || false // false
     ```




- #### 삼항 연산자 (Ternary Conditional Operator)

  - Condition ? expr1 : expr2 

  - Bool 표현식 ? 동일한 자료형 : 동일한 자료형

    ```swift
    let myAgeIs = 29
    
    myAgeIs == 29 ? "true" : "false"
    
    // "true"
    ```



- #### 할당 연산자 (Assignment Operator)

  -  `=` 할당연산자는 값을 저장하는 중요한 역할을 한다. 할당 연산자는 값을 리턴하지 않는다. ✨
  - 할당연산자를 기준으로 lvalue와 rvalue(대부분 literal)로 나뉜다.




- ####  복합 할당 연산자 (Addition Assignment Operator)

  - a += b  == a = a + b
  - a -= b == a = a - b




- #### 범위 연산자 (Range Operator)

  -  `a ... b` 의 형태로 이항 연산자와 사용할 수 있고,
     `a...`  또는  `...a`처럼 단항연산자에도 사용할 수 있다.

    ```swift
    a ... b // a부터 b까지의 범위, 오름차순이 기준이고 내림차순으로 사용하고 싶을 땐
    (a ... b).reversed() // 로 표현한다.
    ```

    📋 단항 연산자로 사용할 땐, 피연산자와 공백없이 붙여서 써야 하고 무한 loop에 빠지지 않도록 주의할 것!

  - Half-Open Range Operator는  a ..< b 처럼 Upperbound가 범위에 포함되지 않는다.
  
- `.contains` 특정한 값이 범위에 포함되는지 확인하는 method ✨
  



- #### 연산자 메소드 (Operator Methods)

  - 컴파일러는 인스턴스를 비교하는 방법을 모르기 때문에, 직접 구현해야 한다.

  - 이미 존재하는 연산자가 새로운 피연산자를 처리할 수 있도록 확장하는 것이기 때문에, 반드시 이미 존재하는 연산자를 사용해야 한다.

  - 우선순위와 결합규칙을 바꾸지 않는다.

  - 삼항 연산자와 할당 연산자는 허용하지 않는다.

    ```swift
    // 연산자 메소드 문법
    
    static func operator(parameters) -> ReturnType {
    	statements
    }
    ```



- #### 연산자 선언 (Custom Operator)

  -  단순해야 하고, 모호하지 않아야 한다.



 *📋 연산자 메소드와 연산자 선언은 다른 문법을 배운 후에 다시 공부할 것*



------



### 2. 기타메모

- `.becomeFirstResponder()` Asks UIKit to make this object the first responder in its window.
  📋  선택한 개체가 첫번째 응답자가 되기를 원할 때 사용
- app crash가 발생하지 않으면 좋지만, 최대한 줄여야 한다. 