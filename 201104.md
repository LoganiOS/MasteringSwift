###### 20/11/04

------



#### Index

### **1. Memory**

### **2. Value Type vs Reference Type**

### **3. ARC (Automatic Reference Counting)**

### 4. Strong Reference Cycle



------



### **1.  Memory**

- #### Bit

  - 컴퓨터 공학에서 사용하는 정보를 나타내는 기본 단위. 0과 1로 표시
  - 최상위 비트는 부호비트(Sign Bit)로 음수와 양수를 결정한다.
  - 2의 보수 방식 : ~로 bitwisenot 연산으로 비트를 반전시키고 +1을 더해준다.



------



### 2. Value Type vs Reference Type

- #### Value Type

  - 값형식
  - 인스턴스를 생성하면 스택에 메모리공간이 생성된다.
  - 함수를 실행할 때마다 새로운 스택 프레임이 추가된다. 가장 최근에 추가된 스택 프레임부터 순서대로 제거된다. (Last In First Out)
  - 값을 복사한다.
  - Copy On Write 최적화가 되어있다.



- #### Reference Type

  - 참조형식 (클로저, 클래스)
  - 동적으로 할당된 데이터가 저장. 공간의 크기를 예측하기 어렵다.
  - 직접 코드를 통해 생성하고 제거해야 한다. 더 이상 필요하지 않은 메모리가 유지되는 메모리 누수(Memory Leaks)가 발생할 수 있다.
  - 실제 값을 힙에 저장하고, 메모리 주소를 스택에 저장한다.
  - 값에 접근해야 할 땐, 스택에 있는 주소를 통해 접근한다.
  - 값의 주소가 복사된다.



------



### 3. ARC (Automatic Reference Counting)

- #### 소유정책과 참조카운트

  - 힙에 저장된 데이터는 필요하지 않은 시점에 직접 제거해야한다.
  - 소유자가 없다면 메모리에서 제거
  - 참조카운트: 제거시점을 파악하기 위해 소유자 수를 저장, 참조카운트가 0이면 메모리에서 제거
  - 인스턴스를 소유하면 참조카운트가 1 증가한다.
  - 인스턴스 소유자가 없다면 참조카운트는 0이고, 메모리에서 제거된다.



------



### 4. Strong Reference Cycle

- #### Strong Reference Cycle

  - ARC가 강한참조싸이클까지 처리해주지 못하므로, 이 문제는 약한참조를 사용해 처리해주어야 한다.
  - 약한참조는 인스턴스를 참조하긴 하지만, 소유하진 않는다.

